# Action Plan: Story 1.1.4 - Agent Tooling Framework (General)

**Story ID:** 1.1.4
**Title:** Agent Tooling Framework (General)
**Assigned Agent:** AGENT-FRAMEWORK
**Dependencies:** T1.1.1 (AutoGen/AG2 + LangGraph Integration), T1.1.2 (Core Agent Dev & Execution Env Setup - for sandbox API), T1.1.6 (LLM Observability - for logging integration)
**Parent Epic:** 1.1 Multi-Agent Infrastructure Setup

## 1. Acceptance Criteria

- A standardized framework for defining, registering, and discovering agent tools is established, supporting tools written in Python and potentially Node.js.
- Tools can be executed securely, leveraging the sandboxed execution environment (from Story 1.1.2) for high-risk operations like code execution or file system access.
- A core set of general-purpose tools is implemented and available, including but not limited to: file I/O, web search, a simple sandboxed code executor, and basic data transformation utilities.
- Agents can declare their tool dependencies, and the framework can dynamically provide or enable these tools for the agent during its lifecycle.
- Tool usage (invocations, parameters, success/failure, duration) is logged in a structured manner and integrated with the observability framework (Story 1.1.6).
- Clear documentation exists for developing, registering, and using tools within the framework.

## 2. Detailed Tasks

This action plan expands on tasks T1.1.4.1 - T1.1.4.7 from `task-breakdown.md`, incorporating insights from `archon-framework-integration.md` (AFI) and `multi-agent-architecture.md` (MAA).

### Task 1.1.4.1: Design Tool Definition Schema
   - **1.1.4.1.1:** Define a comprehensive schema for tool definitions (e.g., using Pydantic models or JSON Schema). This schema should include:
      - `name`: Unique identifier for the tool.
      - `description`: Human-readable description (for agents and developers).
      - `input_schema`: Schema for expected input parameters.
      - `output_schema`: Schema for the expected output/return value.
      - `required_permissions`: (e.g., `file_read`, `file_write`, `web_access`, `code_execution`).
      - `runtime_requirements`: (e.g., `python`, `nodejs`, specific libraries).
      - `version`: Tool version.
      - `is_sandboxed`: Boolean indicating if it must run in the sandbox.
   - **1.1.4.1.2:** Document the tool definition schema and provide examples. (AFI Section 5.3.1.A for `ToolDefinition` concept).

### Task 1.1.4.2: Implement Tool Registry Service/Library
   - **1.1.4.2.1:** Design and implement a `ToolRegistry` where tools can be registered, versioned, and discovered.
      - This could be a dedicated microservice or a library integrated into the core agent framework.
   - **1.1.4.2.2:** Implement functions/endpoints for registering new tools, updating existing tools, and listing available tools (with filtering capabilities).
   - **1.1.4.2.3:** Ensure the registry can store or reference tool definitions and executable code/packages. (MAA Section 4.4.1).

### Task 1.1.4.3: Develop Secure Tool Execution Wrapper
   - **1.1.4.3.1:** Create a `ToolExecutor` component responsible for invoking tools.
   - **1.1.4.3.2:** For tools marked `is_sandboxed: true`, the `ToolExecutor` must interact with the Sandbox API (developed in Story 1.1.2, Task T1.1.2.6) to:
      - Package and deploy the tool's code/dependencies to the sandbox if necessary.
      - Submit the execution request with validated inputs.
      - Retrieve results, logs, and handle errors from the sandbox.
   - **1.1.4.3.3:** For non-sandboxed tools (e.g., simple internal Python functions), the `ToolExecutor` can invoke them directly within the agent's process, but still apply input/output validation based on schemas.
   - **1.1.4.3.4:** Implement robust error handling, timeout mechanisms, and retry logic for tool executions. (MAA Section 4.4.4).

### Task 1.1.4.4: Implement Agent Tool Discovery and Dependency Injection
   - **1.1.4.4.1:** Design how agents declare their required tools or capabilities (e.g., via a configuration file, or attributes on the agent class). (AFI Section 5.2 `AgentCapability.required_tools`).
   - **1.1.4.4.2:** Implement a mechanism within the agent lifecycle (e.g., during initialization or a specific planning phase) to query the `ToolRegistry` for available tools matching the agent's requirements.
   - **1.1.4.4.3:** Make discovered and authorized tools accessible to the agent instance (e.g., injecting them as methods or providing a tool-calling interface). (MAA Section 5.2 `BaseAgent.tools`).
   - **1.1.4.4.4:** Handle cases where required tools are unavailable or the agent lacks permissions.

### Task 1.1.4.5: Develop Initial Set of Common Tools
   - **1.1.4.5.1:** **File I/O Tool (Sandboxed):**
      - Operations: `read_file`, `write_file`, `list_directory`, `get_file_info`.
      - Must operate within paths allowed by the sandbox and agent's permissions.
      - Inputs: file paths, content. Outputs: file content, file list, status.
   - **1.1.4.5.2:** **Web Search Tool (Potentially Sandboxed or API-based):**
      - Operations: `search_web(query, num_results)`.
      - Uses a public search API (e.g., Google Custom Search, Bing Search API, Exa AI) or a library like `googlesearch-python`.
      - Consider sandboxing if it involves direct web requests from an untrusted library.
   - **1.1.4.5.3:** **Basic Code Executor Tool (Sandboxed):**
      - Operations: `execute_python_snippet(code_string)`, `execute_javascript_snippet(code_string)`.
      - Leverages the multi-runtime sandbox (Story 1.1.2) for secure execution.
      - Inputs: code snippet. Outputs: stdout, stderr, return value (if any).
      - (AFI Section 5.3.1.B `CodeExecutionTool` concept).
   - **1.1.4.5.4:** **Data Transformation Tool (Non-Sandboxed, Python-based):**
      - Operations: `json_to_xml`, `xml_to_json`, `csv_to_json`, `text_summarize_simple` (e.g., using a basic algorithm or a small local model if feasible, otherwise flag for LLM-based tool).
      - These would be utility functions callable by agents.
   - **1.1.4.5.5:** Register all developed tools with the `ToolRegistry`.

### Task 1.1.4.6: Integrate Tool Usage Logging with Observability Framework
   - **1.1.4.6.1:** Within the `ToolExecutor`, implement structured logging for every tool invocation.
   - **1.1.4.6.2:** Logged data should include: timestamp, agent_id, tool_name, tool_version, input_parameters (potentially summarized/redacted for PII), success/failure status, duration, output_summary (if applicable), and any error messages.
   - **1.1.4.6.3:** Ensure these logs are formatted and shipped according to the standards defined in the LLM Observability framework (Story 1.1.6).
   - **1.1.4.6.4:** Consider adding tracing spans (e.g., OpenTelemetry) for tool executions to visualize them within broader agent workflows.

### Task 1.1.4.7: Document Tool Framework, Development Guidelines, and Usage
   - **1.1.4.7.1:** Create comprehensive documentation for the agent tooling framework.
   - **1.1.4.7.2:** Provide clear guidelines for developers on how to create new tools: schema definition, implementation best practices, security considerations, registration process.
   - **1.1.4.7.3:** Document how agents can discover and use tools, including examples.
   - **1.1.4.7.4:** Maintain a catalog of available common tools with their descriptions and usage instructions.

## 3. Key Considerations & References

- **Security:** Tool execution, especially for custom or external tools, is a significant security concern. The sandbox is critical. Input validation and permission checks are paramount.
- **Extensibility:** The framework should be designed to easily accommodate new tools, new runtimes (if the sandbox supports them), and evolving agent needs.
- **Tool Granularity:** Strive for tools that are granular enough to be reusable and composable, but not so fine-grained that they lead to overly chatty interactions.
- **Error Handling:** Robust error handling and reporting from tools back to the agent are essential for agent autonomy and debugging.
- **Idempotency:** Where possible, design tools to be idempotent.
- **References:**
    - `archon-framework-integration.md` (AFI): Tool definition concepts (5.3.1), agent capabilities (5.2).
    - `multi-agent-architecture.md` (MAA): Tool integration system (4.4), agent tools (5.2).
    - `ai-development-environment.md` (ADE): Sandbox concepts (2.1, 4.3) which the tool executor will rely on.
    - `llm-observability-management.md`: For integration with logging and tracing standards.
