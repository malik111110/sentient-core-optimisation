# Action Plan: Story 1.1.1 - AutoGen/AG2 + LangGraph Integration

**Story ID:** 1.1.1
**Title:** AutoGen/AG2 + LangGraph Integration
**Assigned Agent:** AGENT-ARCHITECT
**Dependencies:** None
**Parent Epic:** 1.1 Multi-Agent Infrastructure Setup

## 1. Acceptance Criteria

- AutoGen/AG2 principles are reflected in a framework integrated with an event-driven architecture.
- LangGraph is utilized for workflow orchestration, featuring graph-based state management.
- An agent registry and discovery service is operational.
- A basic agent communication protocol (e.g., JSON-RPC 2.0 or similar, as per Archon guide) is implemented.

## 2. Detailed Tasks

This action plan expands on the tasks defined in `task-breakdown.md` (T1.1.1.1 - T1.1.1.8), incorporating insights from `archon-framework-integration.md` (AFI) and `multi-agent-architecture.md` (MAA).

### Task 1.1.1.1: Research and Select Appropriate Framework Versions and Libraries
   - **1.1.1.1.1:** Confirm the interpretation of "AutoGen/AG2". Based on existing project documentation (AFI, MAA), this likely refers to achieving AutoGen-like multi-agent capabilities using a framework like the described "Archon" or a PydanticAI-based system, heavily relying on LangGraph.
   - **1.1.1.1.2:** Solidify choice of LangGraph version. Refer to MAA (Section 3) for `langgraph = "^0.2.0"`.
   - **1.1.1.1.3:** Select core agent framework components. Consider:
      - **Archon-style:** As per AFI, using `archon-ai>=0.2.0`, `pydantic>=2.5.0`, `fastapi`, `celery`, `redis`. (AFI Section 3)
      - **PydanticAI-style:** As per MAA, using `pydantic-ai = "^0.0.13"`, `pydantic = "^2.5.0"`. (MAA Section 3)
      - Evaluate if a hybrid approach or one specific direction is preferred for "AutoGen/AG2" fulfillment.
   - **1.1.1.1.4:** List all primary dependencies and their selected versions. This includes LLM SDKs (OpenAI, Anthropic), database connectors, and utility libraries. (AFI Section 3, MAA Section 3)

### Task 1.1.1.2: Design Core Agent Interaction Model using LangGraph
   - **1.1.1.2.1:** Define the `WorkflowState` schema. This should be a `TypedDict` or Pydantic model representing the shared state across the graph. (MAA Section 5.1 `WorkflowState`)
   - **1.1.1.2.2:** Design the main LangGraph graph structure: identify key nodes (agents/processing steps) and edges (transitions, conditional logic). (MAA Section 4.3, 5.4 `MultiAgentWorkflow`)
   - **1.1.1.2.3:** Specify state update mechanisms within the graph. How does each node read from and write to the `WorkflowState`? (MAA Section 5.4)
   - **1.1.1.2.4:** Plan for conditional routing and error handling within the LangGraph. (MAA Section 4.3.2, 4.3.4, 5.4 `determine_next_step`)

### Task 1.1.1.3: Implement Base Agent Classes
   - **1.1.1.3.1:** Develop `BaseAgent` abstract class. This class should define common agent functionalities.
      - Consider AFI Section 5.2 `BaseAgent` (includes capabilities, message queue, start/stop, send/receive message, heartbeat).
      - Consider MAA Section 5.2 `BaseAgent` (PydanticAI based, includes model, tools, `execute_task`, `run_with_context`).
      - Decide on a unified `BaseAgent` structure or distinct base classes if Archon and PydanticAI approaches are used separately.
   - **1.1.1.3.2:** Define core data models for agent interactions:
      - `AgentCapability` (AFI Section 5.2)
      - `AgentMessage` (AFI Section 5.2) - for inter-agent communication if not solely relying on LangGraph state.
      - `AgentState` (AFI Section 5.2) - for individual agent status tracking.
      - `TaskResult` (AFI Section 5.2, MAA Section 5.1) - for standardized output from agent tasks.
   - **1.1.1.3.3:** Ensure base agents are compatible with the chosen LangGraph state management and node execution patterns.

### Task 1.1.1.4: Develop Agent Registry Service
   - **1.1.1.4.1:** Design the agent registry schema. What information needs to be stored for each agent (ID, name, capabilities, endpoint/handler, status)? (AFI Section 4.1.3, 4.2.4)
   - **1.1.1.4.2:** Choose a storage mechanism for the registry:
      - Simple in-memory store (for PoC).
      - Database (e.g., PostgreSQL via SQLAlchemy as per AFI, or Supabase as per MAA).
      - Discovery protocol (e.g., using Redis for service discovery).
   - **1.1.1.4.3:** Implement CRUD operations for agent registration and lookup.
   - **1.1.1.4.4:** Implement agent health monitoring and status updates in the registry (AFI Section 4.2.5, 5.2 `_heartbeat_loop`).

### Task 1.1.1.5: Implement Communication Layer for Inter-Agent Messaging
   - **1.1.1.5.1:** Confirm if direct inter-agent messaging is needed beyond LangGraph's state-passing. LangGraph typically manages flow, but agents might need to query each other or external services.
   - **1.1.1.5.2:** If direct messaging is required, implement the chosen protocol (e.g., JSON-RPC 2.0). Define message structures (potentially using `AgentMessage` from AFI Section 5.2).
   - **1.1.1.5.3:** Set up transport (e.g., HTTP endpoints via FastAPI, or message queue). (AFI Section 4.4.1)
   - **1.1.1.5.4:** Ensure secure communication if messages contain sensitive data.

### Task 1.1.1.6: Set Up Initial Event-Driven Architecture Components
   - **1.1.1.6.1:** Select and configure a message queue if needed for asynchronous tasks or events outside direct LangGraph flow (e.g., Redis/Celery as per AFI Section 3, 4.4.1).
   - **1.1.1.6.2:** Define key events in the system (e.g., task completion, agent registration, errors).
   - **1.1.1.6.3:** Implement event producers and consumers where necessary. This could tie into LangGraph's execution or be separate for system-level events.

### Task 1.1.1.7: Create a Proof-of-Concept (PoC) Workflow
   - **1.1.1.7.1:** Define a simple multi-step task requiring 2-3 specialized agents (e.g., a requirements analysis agent, a planning agent, a summarization agent).
   - **1.1.1.7.2:** Implement these PoC agents, inheriting from the `BaseAgent` class.
   - **1.1.1.7.3:** Construct the LangGraph graph for this PoC workflow, including state, nodes, and edges. (MAA Section 5.4, 5.5)
   - **1.1.1.7.4:** Execute the PoC workflow and verify that agents collaborate as expected and the final result is achieved.
   - **1.1.1.7.5:** Test basic error handling and state persistence (if implemented).
   - **1.1.1.7.6:** Develop and run unit tests for the PoC agents, core communication components, and LangGraph interactions specific to this PoC, covering T1.1.1.8 from `task-breakdown.md`.

### Task 1.1.1.8: Document the Integration Architecture and PoC
   - **1.1.1.8.1:** Create diagrams illustrating the overall architecture: LangGraph flow, agent interactions, registry, communication paths.
   - **1.1.1.8.2:** Document the `WorkflowState` schema and its usage.
   - **1.1.1.8.3:** Provide examples of how to define and register new agents.
   - **1.1.1.8.4:** Document the PoC workflow: its purpose, agents involved, and execution flow.
   - **1.1.1.8.5:** Store documentation in the project's designated documentation area.

## 3. Key Considerations & References

- **Framework Choice:** The term "AutoGen/AG2" needs clear definition. The plan assumes it means building a robust multi-agent system leveraging LangGraph, potentially with an "Archon"-like custom framework or PydanticAI, as detailed in `archon-framework-integration.md` and `multi-agent-architecture.md`.
- **State Management:** Central to LangGraph. The `WorkflowState` (MAA 5.1) is critical.
- **Agent Definition:** `BaseAgent` (AFI 5.2, MAA 5.2) and specialized agent implementations (MAA 5.3).
- **Configuration:** Ensure all necessary environment variables and configurations from AFI (Section 3, 5.1) and MAA (Section 3) are planned for.
- **Modularity:** Design components (agents, tools, state) to be modular and reusable.
