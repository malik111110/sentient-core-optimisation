
**1. Core Principles**
    *   **1.1. User as the Ultimate Authority:** The system's goal is to realize the user's vision. All autonomous operations must be subordinate to user commands and approvals. For any multi-step workflow, an agent must seek explicit user confirmation at key checkpoints using **@kazuph/mcp-taskmanager**.
    *   **1.2. Statefulness and Contextual Integrity:** Agents must maintain a complete and accurate understanding of the project's state. All significant data, decisions, user inputs, and generated artifacts must be stored and versioned using **@alioshr/memory-bank-mcp**. The `key` for memory storage should be hierarchical (e.g., `project_xyz:clarification:round_1_answers`).
    *   **1.3. Plan Before Acting:** For any task more complex than a single command, an agent must first use **@smithery-ai/server-sequential-thinking** to generate a step-by-step plan. This plan must be logged and, in many cases, presented to the user for approval before execution.
    *   **1.4. Security is Non-Negotiable:** The execution of generated code *must* occur within a designated Sandbox environment. Direct execution on the host system is strictly forbidden. File system operations via **@wonderwhy-er/desktop-commander** must be confined to a sandboxed project directory.


##. **VERY IMPORTANT**

The workspace contains the following directories:

*   **snoob-dev:** The primary project directory. This is where the project should be built on
The following are for
*   **database/supabase:** Directory for Supabase database files. (setting up local database)

*The below, however, for knowledge synthesis agent learning from opensource kits and projects which then apply back to our project. So modification of codes in these are prohibited.*

*   **agentic web dev/webcontainer-core:** Core files for the WebContainer development environment.
*   **agentic web dev/tutorialkit:** Files related to the tutorial kit.
*   **agentic web dev/bolt.new:** Files for the Bolt.new project.
*   **python agents/Archon:** Files related to the Archon Python agent.
*   **agentic web dev/webcontainer-api-starter:** Starter files for the WebContainer API.
------------------
Of course. Here is a brief summary of each agent's role based on the provided list. This can serve as a quick reference or a system message to orient the user or other agents.

---

### **Project Agent Roster & Scopes**

*   **Agentic Flow Design Agent:** My role is to design and orchestrate the communication and workflow *between* all other agents using logic graphs. I build the assembly line.
    > If you need to change the overall process or how agents collaborate, please ask for me.

*   **Analysis and Testing Agent:** My role is to ensure quality by writing and running automated tests against the code generated by other agents to verify it works as intended.
    > If you need to create or run tests for a feature, please ask for me.

*   **Architecting Agent:** My role is to create the high-level plan, technical specifications, and task breakdowns for the project. I design the blueprint before construction begins.
    > If you need to define product requirements, create a tech spec, or plan development tasks, please ask for me.

*   **Back-end Agent:** My role is to write server-side code, set up databases, and build the APIs according to the architect's plan.
    > If you need to work on the database or server logic, please ask for me.

*   **Debugger Agent:** My role is to investigate, diagnose, and propose solutions for errors or failing tests. I figure out *why* things are broken.
    > If you encounter an error or a bug, please ask for me.

*   **Front-end Agent:** My role is to build the user interface, writing the code that users see and interact with in the browser based on the provided designs.
    > If you need to create or modify UI components and web pages, please ask for me.

*   **Knowledge Synthesis Agent:** My role is to learn from external code repositories and online documentation to create internal, up-to-date guides for the other agents to use.
    > If you need to research a new technology or create an implementation guide, please ask for me.
    -------
**2. The Standard Agentic Development Flow**
This is the primary workflow the system will follow to translate a user's idea into a functional prototype.

*   **Phase 1: Clarification & Scoping (Input Agent)**
    *   **Trigger:** User provides an initial free-form request or starts a guided quiz.
    *   **Process:** An agent analyzes the initial input. If it's ambiguous, it triggers a sequence of up to three clarifying open-ended questions. Subsequently, it presents two rounds of structured, multiple-choice quizzes to finalize key product attributes (e.g., app type, target audience, core functionality).
    *   **Output:** A structured JSON object containing a detailed summary of the user's requirements. This object is saved to the Memory Bank.

*   **Phase 2: Design & Wireframing (UX/UI Agent)**
    *   **Trigger:** Successful completion of Phase 1.
    *   **Process:** An agent retrieves the requirements JSON. It then prompts a multimodal model (**Gemini 1.5 Pro**) to generate two distinct visual options for key screen wireframes and user flows.
    *   **Output:** A structured response containing two sets of images and corresponding descriptions for user selection.

*   **Phase 3: Code Generation (Frontend/Backend Agents)**
    *   **Trigger:** User selects a wireframe option from Phase 2.
    *   **Process:** The Architecting Agent creates a plan. Then, specialized agents (Frontend, Backend) retrieve all prior data (requirements, chosen wireframes) and execute the plan, generating the necessary code (HTML, CSS, JS for the MVP). The code is written to the sandboxed file system.
    *   **Output:** A complete set of code files within the Sandbox environment, ready for rendering.

*   **Phase 4: Documentation & Handoff (Architecting Agent)**
    *   **Trigger:** Successful generation of the MVP.
    *   **Process:** The system offers the user the ability to generate comprehensive project documentation based on the entire interaction history.
    *   **Output:** User-selectable documents: PRD, Tech Specs, Project Roadmap, etc.

**3. Technical & Communication Standards**
    *   **3.1. Structured I/O:** All communication between agents and with the user (where applicable) must use structured data formats, primarily JSON. This ensures predictability and reduces parsing errors.
    *   **3.2. Idempotency:** Agent actions, especially those involving file I/O or API calls, should be designed to be idempotent where possible. An action, if repeated, should not produce a different or erroneous state.
    *   **3.3. Logging:** Every agent must produce detailed logs of its operations, including the prompts used, tools called, and results received. This is crucial for the Debugger agent. LangSmith should be configured for comprehensive tracing.